// Generated by IcedCoffeeScript 1.3.3e
(function() {
  var EventEmitter, LRProtocolParser,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = require('events').EventEmitter;

  module.exports = LRProtocolParser = (function(_super) {
    var ERR_ATTR, ERR_CMD, ERR_DATA, ERR_NOPROTO, HANDSHAKE_COMMANDS, HANDSHAKE_PROTOCOL, OPPOSITE_ROLES, VALIDATORS, createError;

    __extends(LRProtocolParser, _super);

    LRProtocolParser.ERR_DATA = ERR_DATA = 'DATA';

    LRProtocolParser.ERR_CMD = ERR_CMD = 'CMD';

    LRProtocolParser.ERR_ATTR = ERR_ATTR = 'ATTR';

    LRProtocolParser.ERR_NOPROTO = ERR_NOPROTO = 'NOPROTO';

    createError = function(code, message) {
      var err;
      err = new Error(message);
      err.isLiveReloadProtocolError = true;
      err.code = code;
      return err;
    };

    VALIDATORS = {
      'required': function(key, message) {
        if (typeof message[key] === 'undefined') {
          throw createError(ERR_ATTR, "Required attribute '" + key + "' is missing in command '" + message.command + "'");
        }
      },
      'string': function(key, message) {
        if (!message.hasOwnProperty(key)) return;
        if (typeof message[key] !== 'string') {
          throw createError(ERR_ATTR, "Attribute '" + key + "' must be a string, got " + (typeof message[key]) + " in command '" + message.command + "'");
        }
      },
      'boolean': function(key, message) {
        if (!message.hasOwnProperty(key)) return;
        if (typeof message[key] !== 'boolean') {
          throw createError(ERR_ATTR, "Attribute '" + key + "' must be a boolean, got " + (typeof message[key]) + " in command '" + message.command + "'");
        }
      },
      'array': function(key, message) {
        if (!message.hasOwnProperty(key)) return;
        if (typeof message[key] !== 'object' || !(message[key] instanceof Array)) {
          throw createError(ERR_ATTR, "Attribute '" + key + "' must be an array, got " + (typeof message[key]) + " in command '" + message.command + "'");
        }
      }
    };

    HANDSHAKE_COMMANDS = {
      'hello': {
        'protocols': ['required', 'array'],
        'id': ['string'],
        'name': ['string'],
        'version': ['string'],
        '*': []
      }
    };

    HANDSHAKE_PROTOCOL = {
      client_commands: HANDSHAKE_COMMANDS,
      server_commands: HANDSHAKE_COMMANDS
    };

    LRProtocolParser.protocols = {
      CONN_CHECK_1: {
        version: 1,
        url: "http://livereload.com/protocols/connection-check-1",
        client_commands: {
          'ping': {
            'token': ['required', 'string']
          },
          'pong': {
            'token': ['required', 'string']
          }
        },
        server_commands: {
          'ping': {
            'token': ['required', 'string']
          },
          'pong': {
            'token': ['required', 'string']
          }
        }
      },
      MONITORING_7: {
        version: 7,
        url: "http://livereload.com/protocols/official-7",
        client_commands: {
          'info': {
            'url': [],
            'plugins': []
          }
        },
        server_commands: {
          'reload': {
            'path': ['required', 'string'],
            'liveCSS': ['boolean'],
            'originalPath': ['string'],
            'overrideURL': ['string']
          }
        }
      },
      SAVING_1: {
        version: 1,
        url: "http://livereload.com/protocols/saving-1",
        client_commands: {
          'save': {
            'url': ['required', 'string'],
            'content': ['required', 'string']
          }
        },
        server_commands: {}
      }
    };

    OPPOSITE_ROLES = {
      'server': 'client',
      'client': 'server'
    };

    function LRProtocolParser(role, supportedProtocols) {
      var key, proto, _i, _j, _len, _len1, _ref, _ref1;
      this.role = role;
      this.supportedProtocols = supportedProtocols;
      this.peerRole = OPPOSITE_ROLES[this.role];
      this.supportedProtocolUrls = [];
      _ref = Object.keys(this.supportedProtocols).sort();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _ref1 = this.supportedProtocols[key];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          proto = _ref1[_j];
          this.supportedProtocolUrls.push(proto.url);
        }
      }
      this.reset();
    }

    LRProtocolParser.prototype.hello = function(_arg) {
      var id, name, version;
      id = _arg.id, name = _arg.name, version = _arg.version;
      if (!id) throw new Error("ERR_INVALID_ARG: id is required");
      if (!name) throw new Error("ERR_INVALID_ARG: name is required");
      if (!version) throw new Error("ERR_INVALID_ARG: version is required");
      return {
        'command': 'hello',
        'protocols': this.supportedProtocolUrls,
        'id': id,
        'name': name,
        'version': version
      };
    };

    LRProtocolParser.prototype.reset = function() {
      this.negotiatedProtocols = null;
      return this.negotiatedProtocolDefinitions = [HANDSHAKE_PROTOCOL];
    };

    LRProtocolParser.prototype.received = function(data) {
      var message;
      try {
        message = JSON.parse(data);
      } catch (e) {
        this.emit('error', createError(ERR_DATA, "The received data is not a valid JSON message; is the client using the old protocol of LiveReload 1.x?"));
        return;
      }
      try {
        this._validate(message, this.peerRole);
      } catch (e) {
        if (!e.isLiveReloadProtocolError) throw e;
        this.emit('error', e);
        return;
      }
      if (message.command === 'hello') {
        this._negotiate(message.protocols);
        if (this.negotiatedProtocolDefinitions.length === 0) {
          return this.emit('error', createError(ERR_NOPROTO, "No supported protocols have been negotiated"));
        } else {
          return this.emit('connected', this.negotiatedProtocols);
        }
      } else {
        return this.emit('command', message);
      }
    };

    LRProtocolParser.prototype.sending = function(message) {
      if (message.command === 'hello') return;
      this._validate(message, this.role);
    };

    LRProtocolParser.prototype._negotiate = function(proposedProtocols) {
      var key, proto, versions, _ref, _results;
      this.negotiatedProtocols = {};
      this.negotiatedProtocolDefinitions = [];
      _ref = this.supportedProtocols;
      _results = [];
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        versions = _ref[key];
        _results.push((function() {
          var _i, _len, _ref1, _results1;
          _results1 = [];
          for (_i = 0, _len = versions.length; _i < _len; _i++) {
            proto = versions[_i];
            if (_ref1 = proto.url, __indexOf.call(proposedProtocols, _ref1) >= 0) {
              this.negotiatedProtocols[key] = proto.version;
              this.negotiatedProtocolDefinitions.push(proto);
              break;
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    LRProtocolParser.prototype._validate = function(message, role) {
      var attr, commands, proto, validAttrs, validCommand, validator, validators, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      if (typeof message.command !== 'string') {
        throw createError(ERR_DATA, "The JSON message is missing a 'command' key");
      }
      validCommand = false;
      validAttrs = [];
      _ref = this.negotiatedProtocolDefinitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        proto = _ref[_i];
        commands = proto["" + role + "_commands"];
        if (commands.hasOwnProperty(message.command)) {
          validCommand = true;
          _ref1 = commands[message.command];
          for (attr in _ref1) {
            if (!__hasProp.call(_ref1, attr)) continue;
            validators = _ref1[attr];
            for (_j = 0, _len1 = validators.length; _j < _len1; _j++) {
              validator = validators[_j];
              VALIDATORS[validator](attr, message);
            }
            validAttrs.push(attr);
          }
        }
      }
      if (!validCommand) {
        throw createError(ERR_CMD, "Invalid command '" + message.command + "'");
      }
      _ref2 = Object.keys(message);
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        attr = _ref2[_k];
        if (attr !== 'command') {
          if (!(__indexOf.call(validAttrs, attr) >= 0 || __indexOf.call(validAttrs, '*') >= 0)) {
            throw createError(ERR_ATTR, "Invalid attribute '" + attr + "' in command '" + message.command + "'");
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    return LRProtocolParser;

  })(EventEmitter);

}).call(this);
